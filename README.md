# pbg
A simple grammar for writing boolean expressions implemented in a small, portable C library.

[about](#about) | [example](#example) | [design goals](#design-goals) | [formal definition](#formal-definition) | [API](#API)


## about

**pbg**, an initialism for Prefix Boolean Grammar, is a simple grammar for writing boolean expressions.

The following is a PBG expression:
```
(& (< [start_date] [end_date]) (= [start_date] 2018-10-12))
```
This expression checks if the start date is before the end date and if the start date is October 12, 2018. It will evaluate to `TRUE` only if both conditions are `TRUE`. 

PBG is designed to be used as a module within [**tbd**, the Tiny Boolean DBMS](https://github.com/imtjd/tbd).


## example

The below example is found in `test/example.c`. It evaluates the expression `(&(=[a][b])(?[d]))` with `[a]=[b]=5.0` and `[c]=6.0`. 
```C
#include "../pbg.h"
#include <stdio.h>
#include <string.h>

/* Our dictionary prototype! */
pbg_field dictionary(char* key, int n);

int main(void)
{
	pbg_error err;
	pbg_expr e;
	
	/* This is the expression string we'll evaluate using our dictionary. */
	/* "Are [a] and [b] the same, and does [d] exist?" */
	char* str = "(&(=[a][b])(?[d]))";
	
	/* Parse the expression string and check if 
	 * there were any compilation errors. */
	pbg_parse(&e, &err, str, strlen(str));
	if(pbg_iserror(&err)) {
		pbg_error_print(&err);
		return 1;
	}
	
	/* Evaluate the expression string and check if 
	 * there were any runtime errors. */
	int result = pbg_evaluate(&e, &err, dictionary);
	if(pbg_iserror(&err)) {
		pbg_error_print(&err);
		return 1;
	}
	
	/* Success! Print the output. */
	printf("%s is %s\n", str, (result == 1) ? "TRUE" : "FALSE");
	return 0;
}

/* This is a simple, handmade dictionary. A more general implementation would 
 * (hopefully) utilize a dictionary data structure. */
pbg_field dictionary(char* key, int n)
{
	PBG_UNUSED(n);  /* Ignore compiler warnings. */
	if(key[0] == 'a' || key[0] == 'b')
		return pbg_make_number(NULL, "5.0", strlen("5.0"));
	if(key[0] == 'c')
		return pbg_make_number(NULL, "6.0", strlen("6.0"));
	return pbg_make_field(PBG_UNKNOWN);
}
```
The output is `FALSE` because `(?[d])` asks if the key `[d]` is defined in the dictionary, which it is not. The expression `(|(=[a][b])(?[d]))` is `TRUE`, however, because `(=[a][b])` asks if `[a]` and `[b]` are equal, which they are.


## design goals

pbg is built with three goals in mind.

First, it must be **simple**. It shouldn't be bogged down by redundant features, it should be easy to express thoughts with, and it must be easy to write an interpreter/compiler for.

Second, it must be **unambigous**. Any expression string must have an unambiguous truth value. Operator precedence invites bugs for the sake of better readability. This seems like a bad idea, so it is avoided.

Third, it must be **expressive**. Thoughts should be easily translated into concise expressions. The grammar falls short of Turing completeness for the sake of simplicity, but it can still go a long way. 


## formal definition

**pbg** is described by a set of simple recursive rules `R`. An expression is a pair `(S,D)`, where `S` is string generated by `R` and `D` is a dictionary. Each expression has a truth value, either `TRUE` or `FALSE`. This truth value is determined by a process of *expression evaluation*. Evaluation is conceptually performed with an abstract syntax tree. Internal nodes of this AST represent operators; leaves, literals.

### literals
Literals come in three flavors: `STRING`, `NUMBER`, and `DATE`. A `STRING` has the form `'.*'`, where `.` denotes any valid character constant. For example, `'Hello, grammar!'` is a valid `STRING`. As is `'123ABC'`. A `NUMBER` has the same form as a [JSON](http://json.org/) number. For example, `1` is a valid `NUMBER`. As are `1.0`, `0.314`, and `4e10`. A `DATE` can be expressed as (most) non-fractional prefixes of `YYYY-MM-DD`. For example, `2018-10-12` is a valid `DATE` denoting October 12, 2018. As are `2018-10`, `2018-10-12`, `2018-10-12`. Notice that `2018` is a `NUMBER`, not a `DATE`.

### operators
Operators are functions that map one or more arguments to a truth value. They are either boolean or non-boolean. For example, `&` is a boolean operator as it acts on a list of expressions, but neither `=` nor `?` are non-boolean operators as they act on literals which do not themselves have truth values. All implemented operators are outlined in the rule set below.

### dictionary
The dictionary `D` is a set of `(KEY,VALUE)` pairs, where each `KEY` is unique. Prior to expression evaluation, every occurrence of `[KEY]` in the string `S` is replaced with its corresponding `VALUE` in `D`. If `KEY` is not in `D`, then `[KEY]` evaluates to the special literal `UNKNOWN`. Similarly to `STRING`, `NUMBER`, and `DATE`, `UNKNOWN` has no truth value. Currently, only the existence operator `?` can take `UNKNOWN` as an argument. (`?` evaluates to `TRUE` only if its argument is not `UNKNOWN`.)

### rules
The following is the set of rules `R` used for generating **pbg** expressions:
```
EXPR
  = (! EXPR)
  = (& EXPR EXPR ...)
  = (| EXPR EXPR ...)
  = (= ANY ANY ...)
  = (!= ANY ANY)
  = (< ANY ANY)
  = (> ANY ANY)
  = (<= ANY ANY)
  = (>= ANY ANY)
  = (? ANY)
  = (@ TYPE VALUE ...)
  = (BOOL)
ANY
  = DATE
  = NUMBER
  = STRING
  = BOOL
  = UNKNOWN
BOOL
  = TRUE
  = FALSE
```


## API

This repository provides a lightweight implementation of a PBG compiler. It can be incorporated into an existing project by including `pbg.h` in your code. Documentation of each API function is provided in `pbg.h` but is partially reproduced here for visibility. The library reserves the `pbg_` and `PBG_` prefixes.

Given a string `S` generated using the [set of rules `R`](#rules), the library converts `S` into an instance of the `pbg_expr` struct.

### functions

```C
/* Parse the string as a PBG expression. If a compilation error occurs, initialize 
 * the provided error argument accordingly. */
void pbg_parse(pbg_expr* e, pbg_error* err, char* str, int n)
```

```C
/* Destroy the PBG expression instance, and free all associated resources. If 
 *`pbg_parse` succeeds, this function must be called to free up internal resources. */
void pbg_free(pbg_expr* e)
```

```C
/* Evaluate the PBG expression with the provided dictionary. If a runtime error 
 * occurs, initialize the provided error argument accordingly. */
int pbg_evaluate(pbg_expr* e, pbg_error* err, pbg_expr_node (*dict)(char*, int))
```

```C
/* Make a `pbg_field` representing the given type. Initialize everything other than 
 * the type to zero. This is useful for creating a `TRUE`, `FALSE`, or `UNKNOWN` field. */
pbg_field pbg_make_field(pbg_field_type type)
```

```C
/* Parse `str` as a `KEY` literal, and return a `pbg_field` representing it. */
pbg_field pbg_make_key(pbg_error* err, char* str, int n)
```

```C
/* Parse `str` as a `DATE` literal, and return a `pbg_field` representing it. */
pbg_field pbg_make_date(pbg_error* err, char* str, int n)
```

```C
/* Parse `str` as a `NUMBER` literal, and return a `pbg_field` representing it. */
pbg_field pbg_make_number(pbg_error* err, char* str, int n)
```

```C
/* Parse `str` as a `STRING` literal, and return a `pbg_field` representing it. */
pbg_field pbg_make_string(pbg_error* err, char* str, int n)
```

```C
/* Identifies the PBG expression type of the given string. */
pbg_node_type pbg_gettype(char* str, int n)
```

```C
/* Prints a human-readable representation of the given error. */
void pbg_error_print(pbg_error* err)
```

```C
/* Frees resources being used by the given error, if any. */
void pbg_error_free(pbg_error* e)
```
